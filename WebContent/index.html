<!DOCTYPE HTML>
<html>
    
    <head>
        <meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link href="css/modern-responsive.css" rel="stylesheet">
        <title>3D visualization Web data statistics</title>
           
        <script type="text/javascript" src="js/threejs/three.js"></script>
		
		<script type="text/javascript" src="js/csg.js"></script>    
		<script type="text/javascript" src="js/ThreeCSG.js"></script> 		
        <script type="text/javascript" src="js/threejs/Detector.js"></script>
        <script type="text/javascript" src="js/threejs/TrackballControls.js"></script>
        <script type="text/javascript" src="js/threejs/OrbitControls.js"></script>
        <script type="text/javascript" src="js/threejs/stats.min.js"></script>
        <script type="text/javascript" src="https://maps.googleapis.com/maps/api/js?key=AIzaSyDwjSVZUk7D3LgeLPHMurDHm5Z-u39IeY0&sensor=false"></script>
       
        <link rel="stylesheet" type="text/css" href="css/modern.css">
        <link href="css/modern-responsive.css" rel="stylesheet">
        <script type='text/javascript' src='js/tween.min.js'></script>
        <script type="text/javascript" src="js/jquery-1.9.1.min.js"></script>
		<!-- modern ui lib -->
        <script type="text/javascript" src="js/metroui/accordion.js"></script>
        <script type="text/javascript" src="js/metroui/buttonset.js"></script>
        <script type="text/javascript" src="js/metroui/calendar.js"></script>
        <script type="text/javascript" src="js/metroui/carousel.js"></script>
        <script type="text/javascript" src="js/metroui/dialog.js"></script>
        <script type="text/javascript" src="js/metroui/dropdown.js"></script>
        <script type="text/javascript" src="js/metroui/input-control.js"></script>
        <script type="text/javascript" src="js/metroui/rating.js"></script>
        <script type="text/javascript" src="js/metroui/slider.js"></script>
        <script type="text/javascript" src="js/metroui/pagecontrol.js"></script>
        <script type="text/javascript" src="js/metroui/tile-drag.js"></script>
        <script type="text/javascript" src="js/metroui/tile-slider.js"></script>
		
		<!--  css -->
        <!-- <link rel="stylesheet" type="text/css" href="css/modern-responsive.css"> -->
        <!-- <link rel="stylesheet" type="text/css" href="css/theme-dark.css"> -->
    </head>
    
    <body class="metrouicss" style="zoom: 1;">
        <div id="container" style="width: 70%; margin: auto; float: left; z-index: -10; position: relative"></div>
       
		<div id="form" style="width: 30%; margin: auto; float: right;z-index: 200; position: relative;background-color: rgba(255,255,255,0.5);">
            <!-- <input type="submit" value="Submit" id="button" />
            <input type="reset" value="Reset" />-->
            <!-- <h2>Form</h2> -->			
			
			<div style="position: relative;margin:10px;">
					<a href="#"> Zoom : </a><a href="#" id="zoom_slide_text"></a>
					<div id="zoom_slider" class="slider" data-role="slider" data-param-init-value="20" data-param-accuracy="20"></div>
			</div>
			<ul class="accordion" data-role="accordion" style="position: relative;margin:10px">
				<li class="active"><a href="#"> Quận/Huyện</a>

					<div id="district" class="row">
						<label class="input-control checkbox indeterminate">
							<input type="checkbox" id="dist_all" name="dist" value="dist_all">	<span class="helper"><b>Chọn tất cả</b></span>

						</label>
						<div id="districtFormContainer" style="-moz-column-count: 3; -webkit-column-count: 3; column-count: 3;">
							<form id="distForm"></form>	<a class="button default" onClick="drawDistGraph()">View</a>

						</div>
					</div>
				</li>
				<li><a href="#"> Thống kê sử dụng </a>

					<div id="dataFormContainer" style="-moz-column-count: 3; -webkit-column-count: 3; column-count: 3;">
						<form id="dataForm">
							<div id="datatype_col">
									<h3>Loại dữ liệu</h3>

							</div>
							<div id="time_col">
									<h3>Thời gian</h3>
							<label class="input-control checkbox indeterminate">
								<input type="checkbox" id="time_all" name="time" value="time_all">	<span class="helper"><b>Chọn tất cả</b></span>

							</label>
							</div>
						</form>	<a class="button default" onClick="drawDatatypeGraph()">View</a>

					</div>
					<li><a href="#"> Đường phố </a>

						<div id="seteetFormContainer" style="-moz-column-count: 2; -webkit-column-count: 2; column-count: 2;">
							<div class="input-control text">
								<input type="text">
								<button class="btn-clear" tabindex="-1" type="button"></button>
							</div>	<a class="button default" onClick="drawStreetGraph()">View</a>
	

						</div>
					</li>
					
					
			</ul>
			
        </div>
        <!-- form jquery -->
        <script type="text/javascript">
            // field showed var
            var images_group = [];
            var images15 = new Array();
            var images14 = new Array();
            var images13 = new Array();
            var district_cb;
             //skybox
            var texture_placeholder;
             //init var
			var hemiLight;
			var SCREEN_WIDTH = window.innerWidth;
			var SCREEN_HEIGHT = window.innerHeight;
            var ZOOM_MIN = 15;
            var BAR_WIDTH = 30;
            var BAR_HEIGHT_MULTIPLE = 10;
            var BAR_WIDTH_DATATYPE = 25;
            var BAR_HEIGHT_MULTIPLE_DATATYPE = 5;
            var BAR_WIDTH_DATATYPE_SPACE = 1;
            var BAR_WIDTH_MULTIPLE = 1;
            var angularSpeed = 0.01; // revolutions per second
            var lastTime = 0;
            if (!Detector.webgl) Detector.addGetWebGLMessage();

            var container, stats;
            var camera, controls, scene, renderer;
            var group_plane, plane;
            var group_cube = [];
             //flag : which graph is showing
            var graphtype_flag = 1; // 1 district , 2 datatype
            var texture, image;
            var strDataURI; // url of map tile
             //MercatorProjection
            var proj;
             //google.maps
            var G;

            var zoom = 13;
            var NWLat, NWLng;
             //var SELat,SELng;
            var STATIC_MAP_HEIGHT = 512,
                STATIC_MAP_WIDTH = 512;
             //var PLANE_WIDTH = 2560,
             //    PLANE_HEIGHT = 2560;
            var TILE_MULTIPLE = 9; //5x5
            var coord = {
                x: 0,
                y: 0
            }
            var map_center_lat = 21.0357;
            var map_center_lng = 105.8261;
            var x_tile = 0;
            var y_tile = 0;
            var tile_center_lng = 0;
            var tile_center_lat = 0;
            var jsonObj;
             //get map tile, calculate lat, lng of tile
            var centerPoint;			
            init_tiles(zoom);
             //getCorners(centerPoint,zoom,STATIC_MAP_HEIGHT,STATIC_MAP_WIDTH);
            latLngToCoord(map_center_lat, map_center_lng);
            console.log("cube pos :" + coord.x + ":" + coord.y);
             //Get fieldName
            $(document).ready(function () {
					
				// handle responsive layout when resize window
				responsive();
                <!-- Show prgress cycle -->
                $("#container").append("<img  src='./images/preloader-w8-line-black.gif'>");
                <!-- SERVLET CALL -->				
                //Check All checkbox
                $("#dist_all").change(function () {
                    if (this.checked) {
                        console.log("dist_all checked");
                        $("input[type='checkbox'][name='dist']").prop("checked", true);
                    } else {
                        console.log("dist_all unchecked");
                        $("input[type='checkbox'][name='dist']").prop("checked", false);
                    }
                });
				$("#time_all").change(function () {
                    if (this.checked) {
                        console.log("time_all checked");
                        $("input[type='checkbox'][name='time']").prop("checked", true);
                    } else {
                        console.log("time_all unchecked");
                        $("input[type='checkbox'][name='time']").prop("checked", false);
                    }
                });
                $.ajax({
                    url: "./StatsGet",
                    type: "GET",
                    dataType: "text",
                    //data:{num1:n1,num2:n2,},
                }).success(function (data) {
                    <!-- Remove prgress cycle -->
                    $("#container").empty();
                    //console.log("done:" + data);
                    jsonObj = eval("(" + data + ")");
                    for (var index = 0; index < jsonObj.fieldNames.length; index++) {
                        switch (jsonObj.fieldNames[index].type) {
                        case 1:
                            // district fieldName
                            var label = $("<label >").attr({
                                class: 'input-control checkbox'
                            });
                            var input = $("<input >");
                            input.attr({
                                type: 'checkbox',
                                name: 'dist',
                                value: jsonObj.fieldNames[index].id
                            });
                            var span = $("<span  style='overflow:hidden;'>").attr({
                                class: 'helper'
                            });
                            span.append(jsonObj.fieldNames[index].name);
                            input.appendTo(label);
                            span.appendTo(label);
                            label.appendTo(distForm);
                            $("#distForm").append("<br/>");
                            break;
                        case 3:
                            // datatype fieldName
                            var label = $("<label>").attr({
                                class: 'input-control checkbox'
                            });
                            var input = $("<input>");
                            input.attr({
                                type: 'checkbox',
                                name: 'datatype',
                                value: jsonObj.fieldNames[index].id
                            });
                            var span = $("<span>").attr({
                                class: 'helper'
                            });
                            span.append(jsonObj.fieldNames[index].name);
                            input.appendTo(label);
                            span.appendTo(label);
                            label.appendTo(datatype_col);
                            $("#datatype_col").append("<br/>");
                            break;
                        case 4:
                            // datatype fieldName
                            var label = $("<label>").attr({
                                class: 'input-control checkbox'
                            });
                            var input = $("<input>");
                            input.attr({
                                type: 'checkbox',
                                name: 'time',
                                value: jsonObj.fieldNames[index].id
                            });
                            var span = $("<span>").attr({
                                class: 'helper'
                            });
                            span.append(jsonObj.fieldNames[index].name);
                            input.appendTo(label);
                            span.appendTo(label);
                            label.appendTo(time_col);
                            $("#time_col").append("<br/>");
                            break;
                        default:
                            break;
                        }
                    }
                    $("#datatype_col").append("<br/>");
                    $("#datatype_col").append("<br/>");
                    $("#datatype_col").append("<br/>");
                    $("#datatype_col").append("<br/>");
                    $("input[type='checkbox'][name='dist']").prop('checked', true);
                    $("input[type='checkbox'][name='time']").prop('checked', true);
                    $("input[type='checkbox'][name='datatype']").prop('checked', true);					;
                    init();
					draw_tiles();
					graph();
                    animate();
					
					$("#zoom_slider").on("change", function(e, val){
						console.log("x"+camera.position.x);
						console.log("z"+camera.position.z);
						CoordtoLatLng(camera.position.x,-camera.position.z);
						console.log(map_center_lat+":"+map_center_lng);
						console.log("zoom_slider changed:"+val);
						
						zoom=val/20+12;
						switch (zoom) {
						case 13:
							BAR_WIDTH_MULTIPLE = 1;
						case 14:
							BAR_WIDTH_MULTIPLE = 0.8;
						case 15:
							BAR_WIDTH_MULTIPLE = 0.6;						
						}
						init_tiles(zoom); 
						init();	
						draw_tiles();
						graph();
						animate();
					});
					// "check all" check box
					 // district check_all
                    $("input[type='checkbox'][name='dist']").change(function () {
                        //console.log("check change,box " + $("input[type='checkbox'][value='4'][name='dist']").get(0).name + " length:" + $("input[type='checkbox'][value='4'][name='dist']").length + " is : " + $("input[type='checkbox'][value='4']")[0].checked);
                        console.log("check change,box " + $(this).attr("name") + " " + $(this).attr("value") + " is " + $(this).is(":checked"));
                        if ($("input[type='checkbox'][name='dist']:not(:checked)").length == 1) {
                            //console.log("1 unchecked");
                            if ($("#dist_all").is(":not(:checked)")) {
                                //console.log("and thats dist_all-> check dist_all now");y
                                $("#dist_all").prop('checked', true);
                            } else {
                                console.log("uncheck idst_all now");
                                $("#dist_all").prop('checked', false);
                            }
                        }
                        //draw mapgraph
                        graph();
                    });
					//street check_all
					$("input[type='checkbox'][name='time']").change(function () {
                        //console.log("check change,box " + $("input[type='checkbox'][value='4'][name='dist']").get(0).name + " length:" + $("input[type='checkbox'][value='4'][name='dist']").length + " is : " + $("input[type='checkbox'][value='4']")[0].checked);
                        console.log("check change,box " + $(this).attr("name") + " " + $(this).attr("value") + " is " + $(this).is(":checked"));
                        if ($("input[type='checkbox'][name='time']:not(:checked)").length == 1) {
                            //console.log("1 unchecked");
                            if ($("#time_all").is(":not(:checked)")) {
                                //console.log("and thats dist_all-> check dist_all now");y
                                $("#time_all").prop('checked', true);
                            } else {
                                console.log("uncheck idst_all now");
                                $("#time_all").prop('checked', false);
                            }
                        }
                        //draw mapgraph
                        graph();
                    });
                    $(window).resize(function () {
                        //console.log("body width:" + $('body').innerWidth());
                        responsive();
                    });
                });
            });
			
				
			// reponsive layout when resizing window
            function responsive() {
                //console.log("body width:" + $('body').innerWidth());
                if ($('body').innerWidth() >= 1340) {
                    $("#districtFormContainer").css("-moz-column-count", "3");
                    $("#districtFormContainer").css("-webkit-column-count", "3");
                    $("#districtFormContainer").css("column-count", "3");

                    $("#dataFormContainer").css("-moz-column-count", "3");
                    $("#dataFormContainer").css("-webkit-column-count", "3");
                    $("#dataFormContainer").css("column-count", "3");
                }
                if ($('body').innerWidth() >= 950 && $('body').innerWidth() < 1340) {
                    $("#districtFormContainer").css("-moz-column-count", "2");
                    $("#districtFormContainer").css("-webkit-column-count", "2");
                    $("#districtFormContainer").css("column-count", "2");

                    $("#dataFormContainer").css("-moz-column-count", "3");
                    $("#dataFormContainer").css("-webkit-column-count", "3");
                    $("#dataFormContainer").css("column-count", "3");
                }
                if ($('body').innerWidth() < 950) {
                    $("#districtFormContainer").css("-moz-column-count", "1");
                    $("#districtFormContainer").css("-webkit-column-count", "1");
                    $("#districtFormContainer").css("column-count", "1");

                    $("#dataFormContainer").css("-moz-column-count", "2");
                    $("#dataFormContainer").css("-webkit-column-count", "2");
                    $("#dataFormContainer").css("column-count", "2");
                }
                if ($('body').innerWidth() < 700) {
                    $("#dataFormContainer").css("-moz-column-count", "1");
                    $("#dataFormContainer").css("-webkit-column-count", "1");
                    $("#dataFormContainer").css("column-count", "1");
                }

            }
			
			

             <!--  Three js Script -->
			
            function drawStreetGraph() {
                BAR_WIDTH = 10;
                BAR_HEIGHT_MULTIPLE_DATATYPE = 20;
                zoom = 15;
                switch (zoom) {
                case 13:
                    BAR_WIDTH_MULTIPLE = 1;
                case 14:
                    BAR_WIDTH_MULTIPLE = 0.8;
                case 15:
                    BAR_WIDTH_MULTIPLE = 0.6;
                };
                camera.position.y = 100;
                camera.position.z = 100;
                TILE_MULTIPLE = 11;
				
                if (graphtype_flag != 3) {
                    graphtype_flag = 3;
                    init_tiles(zoom);
                }
				init();
				draw_tiles();
                graphtype_flag = 3;                
                graph();
                animate();
            }

            function drawDistGraph() {
                BAR_WIDTH = 30;
                BAR_HEIGHT_MULTIPLE_DATATYPE = 10;
                zoom = 13;
                switch (zoom) {
                case 13:
                    BAR_WIDTH_MULTIPLE = 1;
                case 14:
                    BAR_WIDTH_MULTIPLE = 0.8;
                case 15:
                    BAR_WIDTH_MULTIPLE = 0.6;
                };
                camera.position.y = 1300;
                camera.position.z = 1300;
                TILE_MULTIPLE = 11;
				
                if (graphtype_flag == 3) {
                    graphtype_flag = 1;
                    init_tiles(zoom);
                }
				init();
				draw_tiles();
                graphtype_flag = 1;
               

                graph();
                animate();
            }

            function drawDatatypeGraph() {
                BAR_WIDTH = 30;
                BAR_HEIGHT_MULTIPLE_DATATYPE = 10;
                zoom = 13;
                switch (zoom) {
                case 13:
                    BAR_WIDTH_MULTIPLE = 1;
                case 14:
                    BAR_WIDTH_MULTIPLE = 0.8;
                case 15:
                    BAR_WIDTH_MULTIPLE = 0.6;
                };
                camera.position.y = 1300;
                camera.position.z = 1300;
                TILE_MULTIPLE = 11;
                graphtype_flag = 2;
                if (graphtype_flag == 3) {
                    graphtype_flag = 2;
                    init_tiles(zoom);
                }
                graphtype_flag = 2;
                init();
				draw_tiles();
                graph();
                animate();
            }
			
            function init() {
                console.log("init :" + graphtype_flag);
				//CAMERA
				camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 15000);
                camera.position.y = 1300;
                camera.position.z = 1300;
                //camera.rotation.x = 45 * (Math.PI / 180);
                // set some camera attributes
                //var VIEW_ANGLE = 45,
                //    ASPECT = window.innerWidth / window.innerHeight,
                //    NEAR = 1,
                //    FAR = 110000;

                // RENDERER
                renderer = new THREE.WebGLRenderer({
                    antialias: true
                });
                renderer.setSize(window.innerWidth, window.innerHeight);
				// shadow
				renderer.shadowMapEnabled = true;
				renderer.shadowMapSoft = false;
				renderer.gammaInput = true;
				renderer.gammaOutput = true;
				renderer.physicallyBasedShading = true;  
				renderer.shadowMapType=THREE.PCFSoftShadowMap;				
				
                var maxAnisotropy = renderer.getMaxAnisotropy();
               
				//SCENE
                scene = new THREE.Scene();
				//scene.fog = new THREE.Fog( 0xffffff, 1000, 10000 );
                


                // CONTROL
                controls = new THREE.OrbitControls( camera );
				controls.addEventListener( 'change', render );
                controls.rotateSpeed = 1.0;
                controls.zoomSpeed = 1.2;
                controls.panSpeed = 0.1;
                controls.staticMoving = false;
                controls.dynamicDampingFactor = 1.6;
                controls.keys = [65, 83, 68];
				controls.maxPolarAngle = Math.PI/2; 
				controls.maxDistance = 4000;				
				
				//LIGHT
				
                // add subtle ambient lighting
                var ambientLight = new THREE.AmbientLight(0xffffff);
                scene.add(ambientLight);
                // add directional light source
                var directionalLight = new THREE.DirectionalLight(0xffffff,0.1);
                directionalLight.position.set(-1000, 3000, -2000);
				directionalLight.shadowCameraVisible = true;       
                directionalLight.target.position.set(0, 0, 0);
                directionalLight.castShadow = true;
				directionalLight.shadowDarkness = 0.5;
				directionalLight.shadowCameraNear    =  10;
				directionalLight.shadowCameraFar    =  6000;
				directionalLight.shadowCameraRight     =  3000;
				directionalLight.shadowCameraLeft     = -3000;
				directionalLight.shadowCameraTop      =  3000;
				directionalLight.shadowCameraBottom   = -3000;
				directionalLight.shadowMapWidth=Math.pow(2,12);
				directionalLight.shadowMapHeight=Math.pow(2,12);
				directionalLight.shadowBias=-0.0008;
                scene.add(directionalLight);
				
				
				
				/*var directionalLight = new THREE.DirectionalLight(0xffffff,0.1);
                directionalLight.position.set(-1000, 2000, -2000);
                directionalLight.target.position.set(0, 0, 0);
                directionalLight.shadowCameraVisible = true;
                directionalLight.castShadow = true;
				directionalLight.shadowDarkness = 0.5;
				directionalLight.shadowCameraNear    =  500;
				directionalLight.shadowCameraFar    =  4000;
				directionalLight.shadowCameraRight     =  500;
				directionalLight.shadowCameraLeft     = -500;
				directionalLight.shadowCameraTop      =  500;
				directionalLight.shadowCameraBottom   = -500;
                scene.add(directionalLight);	
				
				var directionalLight = new THREE.DirectionalLight(0xffffff,0.1);
                directionalLight.position.set(-1000, 2000, -2000);
                directionalLight.target.position.set(0, 0, 0);
                directionalLight.shadowCameraVisible = true;
                directionalLight.castShadow = true;
				directionalLight.shadowDarkness = 0.5;
				directionalLight.shadowCameraNear    =  500;
				directionalLight.shadowCameraFar    =  4000;
				directionalLight.shadowCameraRight     =  500;
				directionalLight.shadowCameraLeft     = -500;
				directionalLight.shadowCameraTop      =  500;
				directionalLight.shadowCameraBottom   = -500;
                scene.add(directionalLight);		*/
                /*var spotLight = new THREE.SpotLight(0xffffff, 0.05);
                spotLight.position.set(-2000, 2000, -4000);
                spotLight.target.position.set(0, 0, 0);
				spotLight.shadowCameraVisible = true;
                spotLight.castShadow = true;
				spotLight.shadowDarkness = 0.5;
                spotLight.shadowCameraNear = 500;
                spotLight.shadowCameraFar = 10000;
                scene.add(spotLight);*/
				//hemiLight
				hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.05 );
				hemiLight.color.setHSL( 0.6, 1, 0.75 );
				hemiLight.groundColor.setHSL( 0.1, 0.8, 0.7 );
				hemiLight.position.y = 500;
				//scene.add( hemiLight );


                container = document.getElementById('container');
                while (container.firstChild) {
                    container.removeChild(container.firstChild);
                }
                container.appendChild(renderer.domElement);

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                stats.domElement.style.zIndex = 100;
                container.appendChild(stats.domElement);

                //
				

                window.addEventListener('resize', onWindowResize, false);
				var skyDome = new THREE.Mesh(new THREE.SphereGeometry( 5000, 32, 15,0,Math.PI*2 ),new THREE.MeshLambertMaterial({ map: THREE.ImageUtils.loadTexture('images/sky_lightblue_1000.jpg'), side: THREE.BackSide }))
				skyDome.rotation.y = Math.PI;
				scene.add(skyDome);
				
				
                //Axes
                var axes = new THREE.AxisHelper();
                axes.scale.set( 1000, 1000, 1000 );
                scene.add( axes );
				
				// big/base  plane 
                // material
                plane = new THREE.Mesh(new THREE.CircleGeometry( 5000, 20, 0, Math.PI * 2 ), new THREE.MeshLambertMaterial({
                    map: THREE.ImageUtils.loadTexture('images/land.jpg'),	
					overdraw: true
                }));
                plane.position.y = -10;
                plane.rotation.x = -Math.PI / 2;
                plane.rotation.z = Math.PI / 4 + Math.PI / 24;
				//plane.castShadow=true;
				//plane.receiveShadow=true;
                scene.add(plane);
				
            }


            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize(window.innerWidth, window.innerHeight);

                //controls.handleResize();

                render();

            }

            function graph() {
                // Cube				
                for (var i = 0; i < group_cube.length; i++) {
                    scene.remove(group_cube[i]);
                }
                group_cube = [];
                // generate a random multipler for startValue of a cube height when starting tweening
                var min = 0.4;
                var max = 1.3;
                var startMultipler;
                switch (graphtype_flag) {
                case 1:
                    console.log("drawDistGraph");
                    //console.log(jsonObj.streetStats[jsonObj.streetStats.length-1].datatype_count[jsonObj.streetStats[jsonObj.streetStats.length-1].datatype_count.length-1]);

                    // draw district graph
                    for (var index = 0; index < jsonObj.districtStats.length; index++) {

                        //console.log("district_id:"+jsonObj.districtStats[index].district_id);
                        //console.log("checkbox is:"+$("input[type='checkbox'][value="+jsonObj.districtStats[index].district_id+"]").is(':checked'));
                        if ($("input[type='checkbox'][value=" + jsonObj.districtStats[index].district_id + "][name='dist']").is(':checked')) {
                            latLngToCoord(jsonObj.districtStats[index].lat, jsonObj.districtStats[index].lng);
                            //console.log(jsonObj.districtStats[index].data);	
                            // random startMultipler
                            startMultipler = Math.random() * (max - min) + min;
                            var geometry = new THREE.CubeGeometry(1, 1, 1);			
							var color_code=Math.random() * 0xffffff;							
                            for (var i = 0; i < geometry.faces.length; i++) {
                                geometry.faces[i].color.setHex(color_code);
                            }

                            var material = new THREE.MeshLambertMaterial({
                                vertexColors: THREE.FaceColors
                            });
                            var cube = new THREE.Mesh(geometry, material);
                            cube.scale.x = BAR_WIDTH;
                            cube.scale.y = (jsonObj.districtStats[index].data + 0.1) * BAR_HEIGHT_MULTIPLE * startMultipler;
                            cube.scale.z = BAR_WIDTH;
                            cube.position.z = -coord.y;
                            cube.position.x = coord.x;
                            cube.position.y = cube.scale.y / 2;
							//shadow
							cube.castShadow=true;
							cube.receiveShadow=true;
                            // tween
                            var cubeItem = {
                                y: (jsonObj.districtStats[index].data + 0.1) * BAR_HEIGHT_MULTIPLE * startMultipler,
                                mesh: cube
                            };

                            var updateCallback = function () {
                                this.mesh.scale.y = this.y;
                                this.mesh.position.y = this.mesh.scale.y / 2;
                            }
                            var tween = new TWEEN.Tween(cubeItem)
                                .to({
                                y: jsonObj.districtStats[index].data * BAR_HEIGHT_MULTIPLE
                            }, 2000)
                                .delay(0)
                                .onUpdate(updateCallback)
                                .easing(TWEEN.Easing.Elastic.Out)
                                .start();
                            group_cube.push(cube);
                            scene.add(cube);
                        }
                    }
                    break;
                case 2:
                    console.log("drawDatatypeGraph");
                    console.log("data:");
                    // draw datatype stats graph
                    var countSurveyTXT = 0,
                        countSurveyIMG = 0,
                        countSurveyAUD = 0,
                        countSurveyVID = 0,
                        curDistrict;
                    //loop thourgh dataTypeStats Item
                    for (var index = 0; index < jsonObj.dataTypeStats.length; index++) {
                        countSurveyTXT = 0.1, countSurveyIMG = 0.1, countSurveyAUD = 0.1, countSurveyVID = 0.1, curDistrict = jsonObj.dataTypeStats[index].district_id;

                        latLngToCoord(jsonObj.dataTypeStats[index].lat, jsonObj.dataTypeStats[index].lng);
                        // random startMultipler
                        startMultipler = Math.random() * (max - min) + min;
                        // for each dataType item , loop thourgh each district , count & add to countSurvey
                        while (index < jsonObj.dataTypeStats.length && curDistrict == jsonObj.dataTypeStats[index].district_id) {

                            // if its time-checkbox is checked , count that data
                            if ($("input[type='checkbox'][value=" + jsonObj.dataTypeStats[index].time_id + "][name='time']").is(':checked')) { // count only checked_time 
                                //console.log("index:"+index);
                                //console.log("jsonObj.dataTypeStats[index].datatype:"+jsonObj.dataTypeStats[index].datatype_id);
                                //if(jsonObj.dataTypeStats[index].datatype_id==1){
                                //	countSurveyTXT++;
                                //}
                                switch (jsonObj.dataTypeStats[index].datatype_id) {
                                case 1:
                                    countSurveyTXT += jsonObj.dataTypeStats[index].data;
                                    break;
                                case 2:
                                    countSurveyIMG += jsonObj.dataTypeStats[index].data;
                                    break;
                                case 3:
                                    countSurveyAUD += jsonObj.dataTypeStats[index].data;
                                    break;
                                case 4:
                                    countSurveyVID += jsonObj.dataTypeStats[index].data;
                                    break;
                                default:
                                    console.log(jsonObj.dataTypeStats[index].data);
                                    break;
                                }

                            }
                            // increase index
                            index++;
                        }


                        for (var datatype_index = 1; datatype_index <= 4; datatype_index++) {
                            // draw only checked_datatype and checked_district and inside map
                            if ($("input[type='checkbox'][value=" + datatype_index + "][name='datatype']").is(':checked') && $("input[type='checkbox'][value=" + jsonObj.dataTypeStats[index - 1].district_id + "][name='dist']").is(':checked')
							&&Math.abs(coord.x)<STATIC_MAP_HEIGHT*TILE_MULTIPLE/2) {
                                //console.log("curDistrict:"+curDistrict);
                                //console.log("jsonObj.dataTypeStats[index-1].district_id :"+jsonObj.dataTypeStats[index-1].district_id );
                                //bar position

                                switch (datatype_index) {
                                case 1:
                                    var geometry = new THREE.CubeGeometry(1, 1, 1);
                                    for (var i = 0; i < geometry.faces.length; i++) {
                                        geometry.faces[i].color.setHex(Math.random() * 0xffffff);
                                    }
                                    var material = new THREE.MeshPhongMaterial({
                                        vertexColors: THREE.FaceColors
                                    });
                                    var cube = new THREE.Mesh(geometry, material);
                                    cube.scale.x = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.scale.y = countSurveyTXT * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler;
                                    cube.scale.z = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.z = -(coord.y - BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE);
                                    cube.position.x = coord.x - BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.y = cube.scale.y / 2;
									//shadow
									cube.castShadow=true;
									cube.receiveShadow=true;
                                    // tween
                                    var cubeItem = {
                                        y: countSurveyTXT * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler,
                                        mesh: cube
                                    };

                                    var updateCallback = function () {
                                        this.mesh.scale.y = this.y;
                                        this.mesh.position.y = this.mesh.scale.y / 2;
                                        //console.log("cube.scale.y:" + this.mesh.scale.y);
                                    }
                                    var tween = new TWEEN.Tween(cubeItem)
                                        .to({
                                        y: countSurveyTXT * BAR_HEIGHT_MULTIPLE_DATATYPE
                                    }, 2000)
                                        .delay(0)
                                        .onUpdate(updateCallback)
                                        .easing(TWEEN.Easing.Elastic.Out)
                                        .start();
                                    group_cube.push(cube);
                                    scene.add(cube);
                                    break;
                                case 2:
                                    var geometry = new THREE.CubeGeometry(1, 1, 1);
                                    for (var i = 0; i < geometry.faces.length; i++) {
                                        geometry.faces[i].color.setHex(Math.random() * 0xffffff);
                                    }
                                    var material = new THREE.MeshLambertMaterial({
                                        vertexColors: THREE.FaceColors
                                    });
                                    var cube = new THREE.Mesh(geometry, material);
                                    cube.scale.x = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.scale.y = countSurveyIMG * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler;
                                    cube.scale.z = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.z = -(coord.y - BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE);
                                    cube.position.x = coord.x + BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.y = cube.scale.y / 2;
									//shadow
									cube.castShadow=true;
									cube.receiveShadow=true;
                                    // tween
                                    var cubeItem = {
                                        y: countSurveyIMG * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler,
                                        mesh: cube
                                    };

                                    var updateCallback = function () {
                                        this.mesh.scale.y = this.y;
                                        this.mesh.position.y = this.mesh.scale.y / 2;
                                    }
                                    var tween = new TWEEN.Tween(cubeItem)
                                        .to({
                                        y: countSurveyIMG * BAR_HEIGHT_MULTIPLE_DATATYPE
                                    }, 2000)
                                        .delay(0)
                                        .onUpdate(updateCallback)
                                        .easing(TWEEN.Easing.Elastic.Out)
                                        .start();
                                    group_cube.push(cube);
                                    scene.add(cube);
                                    break;
                                case 3:
                                    var geometry = new THREE.CubeGeometry(1, 1, 1);
                                    for (var i = 0; i < geometry.faces.length; i++) {
                                        geometry.faces[i].color.setHex(Math.random() * 0xffffff);
                                    }
                                    var material = new THREE.MeshLambertMaterial({
                                        vertexColors: THREE.FaceColors
                                    });
                                    var cube = new THREE.Mesh(geometry, material);
                                    cube.scale.x = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.scale.y = countSurveyAUD * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler;
                                    cube.scale.z = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.z = -(coord.y + BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE);
                                    cube.position.x = coord.x - BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;

                                    cube.position.y = cube.scale.y / 2;
									//shadow
									cube.castShadow=true;
									cube.receiveShadow=true;
                                    // tween
                                    var cubeItem = {
                                        y: countSurveyAUD * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler,
                                        mesh: cube
                                    };

                                    var updateCallback = function () {
                                        this.mesh.scale.y = this.y;
                                        this.mesh.position.y = this.mesh.scale.y / 2;
                                        //console.log("cube.scale.y:" + this.mesh.scale.y);
                                    }
                                    var tween = new TWEEN.Tween(cubeItem)
                                        .to({
                                        y: countSurveyAUD * BAR_HEIGHT_MULTIPLE_DATATYPE
                                    }, 2000)
                                        .delay(0)
                                        .onUpdate(updateCallback)
                                        .easing(TWEEN.Easing.Elastic.Out)
                                        .start();
                                    group_cube.push(cube);
                                    scene.add(cube);
                                    break;
                                case 4:
                                    var geometry = new THREE.CubeGeometry(1, 1, 1);
                                    for (var i = 0; i < geometry.faces.length; i++) {
                                        geometry.faces[i].color.setHex(Math.random() * 0xffffff);
                                    }
                                    var material = new THREE.MeshLambertMaterial({
                                        vertexColors: THREE.FaceColors
                                    });
                                    var cube = new THREE.Mesh(geometry, material);
                                    cube.scale.x = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.scale.y = countSurveyVID * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler;
                                    cube.scale.z = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.z = -(coord.y + BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE);
                                    cube.position.x = coord.x + BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.y = cube.scale.y / 2;
                                    //shadow
									cube.castShadow=true;
									cube.receiveShadow=true;
									// tween
                                    var cubeItem = {
                                        y: countSurveyVID * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler,
                                        mesh: cube
                                    };

                                    var updateCallback = function () {
                                        this.mesh.scale.y = this.y;
                                        this.mesh.position.y = this.mesh.scale.y / 2;
                                        //console.log("cube.scale.y:" + this.mesh.scale.y);
                                    }
                                    var tween = new TWEEN.Tween(cubeItem)
                                        .to({
                                        y: countSurveyVID * BAR_HEIGHT_MULTIPLE_DATATYPE
                                    }, 2000)
                                        .delay(0)
                                        .onUpdate(updateCallback)
                                        .easing(TWEEN.Easing.Elastic.Out)
                                        .start();
                                    group_cube.push(cube);
                                    scene.add(cube);
                                    break;
                                default:
                                    console.log("countSurvey:" + countSurveyTXT + ":" + countSurveyIMG + ":" + countSurveyAUD + ":" + countSurveyVID);
                                    break;
                                }
                            }

                        }




                    }
                    break;
                case 3:
                    console.log("drawStreetGraph");
                    // draw district graph
                    // draw datatype stats graph
                    //loop thourgh dataTypeStats Item
                    for (var index = 0; index < jsonObj.streetStats.length; index++) {
                        var countSurveyTXT = 0,
                            countSurveyIMG = 0,
                            countSurveyAUD = 0,
                            countSurveyVID = 0,
                            curStreet;
                        countSurveyTXT = 0.1, countSurveyIMG = 0.1, countSurveyAUD = 0.1, countSurveyVID = 0.1, curStreet = jsonObj.streetStats[index].street_id;
                        var datatypejsonObj = eval(jsonObj.streetStats[index].datatype_count);
                        latLngToCoord(jsonObj.streetStats[index].lat, jsonObj.streetStats[index].lng);
                        // random startMultipler
                        startMultipler = Math.random() * (max - min) + min;
                        // for each dataType item , loop thourgh each district , count & add to countSurvey

                        for (var i = 0; i < datatypejsonObj.length; i++) {
                            for (var j = 0; j < datatypejsonObj[0].length; j++) {
                                // if its time-checkbox is checked , count that data
                                if ($("input[type='checkbox'][value=" + j + "][name='time']").is(':checked')) { // count only checked_time 
                                    //console.log("index:"+index);
                                    //console.log("jsonObj.dataTypeStats[index].datatype:"+jsonObj.dataTypeStats[index].datatype_id);
                                    //if(jsonObj.dataTypeStats[index].datatype_id==1){
                                    //	countSurveyTXT++;
                                    //}
                                    //console.log("datatypejsonObj[" + i + "][" + j + "].count" + datatypejsonObj[i][j]);
                                    switch (i) {
                                    case 0:
                                        countSurveyTXT += datatypejsonObj[i][j];
                                        break;
                                    case 1:
                                        countSurveyIMG += datatypejsonObj[i][j];
                                        break;
                                    case 2:
                                        countSurveyAUD += datatypejsonObj[i][j];
                                        break;
                                    case 3:
                                        countSurveyVID += datatypejsonObj[i][j];
                                        break;
                                    default:
                                        console.log(datatypejsonObj[i][j]);
                                        break;
                                    }

                                }
                            }

                        }

                        for (var datatype_index = 1; datatype_index <= 4; datatype_index++) {

                            // draw only checked_datatype & checked_district & inside map
                            if ($("input[type='checkbox'][value=" + datatype_index + "][name='datatype']").is(':checked') && $("input[type='checkbox'][value=" + jsonObj.streetStats[index].district_id + "][name='dist']").is(':checked')
							&&Math.abs(coord.x)<STATIC_MAP_HEIGHT*TILE_MULTIPLE/2) {
                               
                                //console.log("jsonObj.dataTypeStats[index-1].district_id :"+jsonObj.dataTypeStats[index-1].district_id );
                                //bar position
                                switch (datatype_index) {
                                case 1:
                                    var geometry = new THREE.CubeGeometry(1, 1, 1);
                                    for (var i = 0; i < geometry.faces.length; i++) {
                                        geometry.faces[i].color.setHex(Math.random() * 0xffffff);
                                    }
                                    var material = new THREE.MeshLambertMaterial({
                                        vertexColors: THREE.FaceColors
                                    });
                                    var cube = new THREE.Mesh(geometry, material);
                                    cube.scale.x = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.scale.y = countSurveyTXT * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler;
                                    cube.scale.z = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.z = -(coord.y - BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE);
                                    cube.position.x = coord.x - BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.y = cube.scale.y / 2;
									//shadow
									cube.castShadow=true;
									//cube.receiveShadow=true;
                                    // tween
                                    var cubeItem = {
                                        y: countSurveyTXT * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler,
                                        mesh: cube
                                    };

                                    var updateCallback = function () {
                                        this.mesh.scale.y = this.y;
                                        this.mesh.position.y = this.mesh.scale.y / 2;
                                        //console.log("cube.scale.y:" + this.mesh.scale.y);
                                    }
                                    var tween = new TWEEN.Tween(cubeItem)
                                        .to({
                                        y: countSurveyTXT * BAR_HEIGHT_MULTIPLE_DATATYPE
                                    }, 2000)
                                        .delay(0)
                                        .onUpdate(updateCallback)
                                        .easing(TWEEN.Easing.Elastic.Out)
                                        .start();
                                    group_cube.push(cube);
                                    scene.add(cube);
                                    break;
                                case 2:
                                    var geometry = new THREE.CubeGeometry(1, 1, 1);
                                    for (var i = 0; i < geometry.faces.length; i++) {
                                        geometry.faces[i].color.setHex(Math.random() * 0xffffff);
                                    }
                                    var material = new THREE.MeshLambertMaterial({
                                        vertexColors: THREE.FaceColors
                                    });
                                    var cube = new THREE.Mesh(geometry, material);
                                    cube.scale.x = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.scale.y = countSurveyIMG * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler;
                                    cube.scale.z = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.z = -(coord.y - BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE);
                                    cube.position.x = coord.x + BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.y = cube.scale.y / 2;
									//shadow
									cube.castShadow=true;
									//cube.receiveShadow=true;
                                    // tween
                                    var cubeItem = {
                                        y: countSurveyIMG * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler,
                                        mesh: cube
                                    };

                                    var updateCallback = function () {
                                        this.mesh.scale.y = this.y;
                                        this.mesh.position.y = this.mesh.scale.y / 2;
                                    }
                                    var tween = new TWEEN.Tween(cubeItem)
                                        .to({
                                        y: countSurveyIMG * BAR_HEIGHT_MULTIPLE_DATATYPE
                                    }, 2000)
                                        .delay(0)
                                        .onUpdate(updateCallback)
                                        .easing(TWEEN.Easing.Elastic.Out)
                                        .start();
                                    group_cube.push(cube);
                                    scene.add(cube);
                                    break;
                                case 3:
                                    var geometry = new THREE.CubeGeometry(1, 1, 1);
                                    for (var i = 0; i < geometry.faces.length; i++) {
                                        geometry.faces[i].color.setHex(Math.random() * 0xffffff);
                                    }
                                    var material = new THREE.MeshLambertMaterial({
                                        vertexColors: THREE.FaceColors
                                    });
                                    var cube = new THREE.Mesh(geometry, material);
                                    cube.scale.x = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.scale.y = countSurveyAUD * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler;
                                    cube.scale.z = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.z = -(coord.y + BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE);
                                    cube.position.x = coord.x - BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.y = cube.scale.y / 2;
									//shadow
									cube.castShadow=true;
									//cube.receiveShadow=true;
                                    // tween
                                    var cubeItem = {
                                        y: countSurveyAUD * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler,
                                        mesh: cube
                                    };

                                    var updateCallback = function () {
                                        this.mesh.scale.y = this.y;
                                        this.mesh.position.y = this.mesh.scale.y / 2;
                                        //console.log("cube.scale.y:" + this.mesh.scale.y);
                                    }
                                    var tween = new TWEEN.Tween(cubeItem)
                                        .to({
                                        y: countSurveyAUD * BAR_HEIGHT_MULTIPLE_DATATYPE
                                    }, 2000)
                                        .delay(0)
                                        .onUpdate(updateCallback)
                                        .easing(TWEEN.Easing.Elastic.Out)
                                        .start();
                                    group_cube.push(cube);
                                    scene.add(cube);
                                    break;
                                case 4:
                                    var geometry = new THREE.CubeGeometry(1, 1, 1);
                                    for (var i = 0; i < geometry.faces.length; i++) {
                                        geometry.faces[i].color.setHex(Math.random() * 0xffffff);
                                    }
                                    var material = new THREE.MeshLambertMaterial({
                                        vertexColors: THREE.FaceColors
                                    });
                                    var cube = new THREE.Mesh(geometry, material);
                                    cube.scale.x = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.scale.y = countSurveyVID * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler;
                                    cube.scale.z = BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.z = -(coord.y + BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE);
                                    cube.position.x = coord.x + BAR_WIDTH_DATATYPE_SPACE * BAR_WIDTH_DATATYPE * BAR_WIDTH_MULTIPLE;
                                    cube.position.y = cube.scale.y / 2;
									//shadow
									cube.castShadow=true;
									//cube.receiveShadow=true;
                                    // tween
                                    var cubeItem = {
                                        y: countSurveyVID * BAR_HEIGHT_MULTIPLE_DATATYPE * startMultipler,
                                        mesh: cube
                                    };

                                    var updateCallback = function () {
                                        this.mesh.scale.y = this.y;
                                        this.mesh.position.y = this.mesh.scale.y / 2;
                                        //console.log("cube.scale.y:" + this.mesh.scale.y);
                                    }
                                    var tween = new TWEEN.Tween(cubeItem)
                                        .to({
                                        y: countSurveyVID * BAR_HEIGHT_MULTIPLE_DATATYPE
                                    }, 2000)
                                        .delay(0)
                                        .onUpdate(updateCallback)
                                        .easing(TWEEN.Easing.Elastic.Out)
                                        .start();
                                    group_cube.push(cube);
                                    scene.add(cube);
                                    break;
                                default:
                                    //console.log("countSurvey:" + countSurveyTXT + ":" + countSurveyIMG + ":" + countSurveyAUD + ":" + countSurveyVID);
                                    break;
                                }
                            }

                        }                   
                    }
                    break;
                default:
                    break;
                }
            }

            function animate() {
                requestAnimationFrame(animate);
                //tween
                TWEEN.update();
				//zoom
				if(camera.position.y<500&&camera){
				}
				
                // update
	
                var date = new Date();
                var time = date.getTime();
                var timeDiff = time - lastTime;
                var angleChange = angularSpeed * timeDiff * 2 * Math.PI / 1000;
                //plane.rotation.z += angleChange;
                //cube.rotation.z += angleChange;

                lastTime = time;

                render();
                update();


            }

            function update() {
                //controls.panSpeed = camera.position.y/1000;
                //console.log("cam.pos.y:spd"+camera.position.y+":"+controls.panSpeed);
                controls.update();
                //camera.position.z = Math.max( camera.position.z, 50);
                stats.update();
            }

            function render() {
                renderer.render(scene, camera);
                //console.log(camera.position.x+":"+camera.position.y+":"+camera.position.z);		
                //console.log("rot"+camera.rotation.x+":"+camera.rotation.y+":"+camera.rotation.z);
            }

            function getCorners(center, zoom, mapWidth, mapHeight) {
                var scale = Math.pow(2, zoom);
                var centerPx = proj.fromLatLngToPoint(center);
                var SWPoint = {
                    x: (centerPx.x - (mapWidth / 2) / scale),
                    y: (centerPx.y + (mapHeight / 2) / scale)
                };
                SWLatLng = proj.fromPointToLatLng(SWPoint);
                //console.log('SW: ' + SWLatLng);
                var NEPoint = {
                    x: (centerPx.x + (mapWidth / 2) / scale),
                    y: (centerPx.y - (mapHeight / 2) / scale)
                };
                NELatLng = proj.fromPointToLatLng(NEPoint);
                //console.log(' NE: '+ NELatLng);
            }

             //skybox

            function loadTexture(path) {

                var texture = new THREE.Texture(texture_placeholder);
                var material = new THREE.MeshLambertMaterial({
                    map: texture,
                    overdraw: true
                });

                var image = new Image();
                image.onload = function () {

                    texture.needsUpdate = true;
                    material.map.image = this;

                    render();

                };
                image.src = path;

                return material;

            }
             //get map tile, calculate lat, lng of tile

            function init_tiles(zoom) {
				console.log("init_tile:"+zoom);
                //proj = new MercatorProjection();
                G = google.maps;
                // get x y of the tile in selected lat-lng	
                x_tile = long2tile(map_center_lng, zoom);
                y_tile = lat2tile(map_center_lat, zoom);
                //get lat - lng of the center of the tile image fetched
                tile_center_lng = tile2long(x_tile + 0.5, zoom); // + 0.5 to return center point , return NW corner by default 
                tile_center_lat = tile2lat(y_tile + 0.5, zoom);
                NWLng = tile2long(x_tile, zoom);
                NWLat = tile2lat(y_tile, zoom);
                //SELat = tile2long(x_tile+1,zoom);
                //SELng = tile2lat(x_tile+1,zoom);
                //strDataURI = "http://b.tile.openstreetmap.org/"+zoom+"/"+x_tile+"/"+y_tile+".png";
                console.log("zoom :" + zoom);
                console.log("x_tile :" + long2tile(map_center_lng, zoom));
                console.log("y_tile :" + lat2tile(map_center_lat, zoom));
                console.log("tile center long:" + tile2long(x_tile + 0.5, zoom));
                console.log("tile center lat :" + tile2lat(y_tile + 0.5, zoom));
                console.log("tile NW long:" + tile2long(x_tile, zoom));
                console.log("tile NW lat :" + tile2lat(y_tile, zoom));
                centerPoint = new G.LatLng(tile_center_lat, tile_center_lng);
				
				
            }
			function draw_tiles() {
			//group
                group_plane = new THREE.Object3D();
				//group_plane.castShadow=true;
				//group_plane.receiveShadow=true;
                
                // plane
                for (var i = -(TILE_MULTIPLE - 1) / 2; i <= (TILE_MULTIPLE - 1) / 2; i++) {
                    for (var j = -(TILE_MULTIPLE - 1) / 2; j <= (TILE_MULTIPLE - 1) / 2; j++) {


                        //texture
                        //image = document.getElementById("myCanvas");

                        //imageContext = image.getContext( '2d' );
                        //imageContext.fillStyle = '#FF0000';
                        //imageContext.fillRect(0,0,150,75);

                        texture = new THREE.Texture(image);
                        // material
                        var material = new THREE.MeshLambertMaterial({
                            map: THREE.ImageUtils.loadTexture(getURL(i, j)),
                            //map: texture
                            
                            overdraw: true,
                            opacity: 1,
                            transparent: false
                        });
						//material.castShadow=true;
						//material.receiveShadow=true;
                        //console.log(getURL(i,j));
                        plane = new THREE.Mesh(new THREE.PlaneGeometry(STATIC_MAP_WIDTH, STATIC_MAP_HEIGHT, 1, 1), material);
                        plane.overdraw = true;
                        plane.doubleSided = true;
                        plane.position.z = -j * STATIC_MAP_HEIGHT;
                        plane.position.x = i * STATIC_MAP_WIDTH;
                        plane.rotation.x = -Math.PI / 2;
                        plane.material.side = THREE.DoubleSide;
						//plane.castShadow=true;
						plane.receiveShadow=true;
                        group_plane.add(plane);
                    }
                }
                scene.add(group_plane);
			}
             // GET URL OF TILE

            function getURL(x_offset, y_offset) {
                var temp_x = x_tile + x_offset;
                var temp_y = y_tile - y_offset; // map tile aray count from top left , coord count from left botom
                // select random server
                var servers = [
                        "a",
                        "b",
                        "c"
                ];
                var server = servers[Math.floor(Math.random() * servers.length)];
                return "http://" + server + ".tile.openstreetmap.org/" + zoom + "/" + temp_x + "/" + temp_y + ".png";
            }
             // draw canvas	
             // utils function

            function long2tile(lon, zoom) {
                return (Math.floor((lon + 180) / 360 * Math.pow(2, zoom)));
            }

            function lat2tile(lat, zoom) {
                return (Math.floor((1 - Math.log(Math.tan(lat * Math.PI / 180) + 1 / Math.cos(lat * Math.PI / 180)) / Math.PI) / 2 * Math.pow(2, zoom)));
            }

            function tile2long(x, z) {
                return (x / Math.pow(2, z) * 360 - 180);
            }

            function tile2lat(y, z) {
                var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
                return (180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));
            }

             // convert LatLng to coordination in the scene

            function latLngToCoord(lat, lng) {
                //console.log(' PLANE_HEIGHT: '+ PLANE_HEIGHT);
                //console.log(' PLANE_WIDTH: '+ PLANE_WIDTH);
                //console.log(' centerPoint.lat(): '+ centerPoint.lat());
                //console.log(' centerPoint.lng(): '+ centerPoint.lng());
                //console.log(' NWLat: '+ NWLat);
                //console.log(' NWLng: '+ NWLng);
                coord.y = (STATIC_MAP_HEIGHT / 2) * ((lat - centerPoint.lat()) / (NWLat - centerPoint.lat()));
                coord.x = (STATIC_MAP_WIDTH / 2) * ((lng - centerPoint.lng()) / (centerPoint.lng() - NWLng));
            }
			function CoordtoLatLng(x, y) {
                //console.log(' PLANE_HEIGHT: '+ PLANE_HEIGHT);
                //console.log(' PLANE_WIDTH: '+ PLANE_WIDTH);
                //console.log(' centerPoint.lat(): '+ centerPoint.lat());
                //console.log(' centerPoint.lng(): '+ centerPoint.lng());
                console.log(' NWLat: '+ NWLat);
                console.log(' NWLng: '+ NWLng);
				map_center_lat = (y/(STATIC_MAP_HEIGHT / 2))*(NWLat - centerPoint.lat()) + centerPoint.lat();
				map_center_lng = (x/(STATIC_MAP_HEIGHT / 2))*(centerPoint.lng() - NWLng) + centerPoint.lng();            
            }
        </script>
		<!--Shader-->
		<script type="x-shader/x-vertex" id="vertexShader">

			varying vec3 vWorldPosition;

			void main() {

				vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
				vWorldPosition = worldPosition.xyz;

				gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentShader">

			uniform vec3 topColor;
			uniform vec3 bottomColor;
			uniform float offset;
			uniform float exponent;

			varying vec3 vWorldPosition;

			void main() {

				float h = normalize( vWorldPosition + offset ).y;
				gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( h, exponent ), 0.0 ) ), 1.0 );

			}

		</script>
    </body>

</html>